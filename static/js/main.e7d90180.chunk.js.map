{"version":3,"sources":["sw.js","index.js"],"names":["registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","catch","error","isLocalhost","Boolean","window","location","hostname","match","require","post","id","response","crypto","url","search","launchParams","slice","indexOf","searchOrParsedUrlQuery","secretKey","sign","queryParams","processQueryParam","key","value","startsWith","push","formattedSearch","split","Object","keys","length","queryString","sort","a","b","localeCompare","reduce","acc","idx","encodeURIComponent","createHmac","update","digest","toString","replace","verifyLaunchParams","alert","connect","send","URL","process","origin","addEventListener","fetch","status","headers","get","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"igBAUA,SAASA,EAAgBC,GACxBC,UAAUC,cACRC,SAASH,GACTI,MAAK,SAACC,GACNA,EAAaC,cAAgB,WAC5B,IAAMC,EAAmBF,EAAaG,WACtCD,EAAiBE,cAAgB,WACD,cAA3BF,EAAiBG,QAChBT,UAAUC,cAAcS,WAK3BC,QAAQC,IAAI,6CAKZD,QAAQC,IAAI,4CAMhBC,OAAM,SAACC,GACPH,QAAQG,MAAM,4CAA6CA,MA6B9D,IAAMC,EAAcC,QAAqC,cAA7BC,OAAOC,SAASC,UAEd,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MAAM,2DC1DbC,EAAQ,KAEhBC,KAAK,6CAA8C,CACtDC,GAAI,MAEPpB,MAAK,SAASqB,OAIf,IAAMC,EAASJ,EAAQ,KA4EvB,IAAMK,EAAMT,OAAOC,SAASS,OAItBC,EAAeF,EAAIG,MAAMH,EAAII,QAAQ,KAAO,IAxElD,SAA4BC,EAAwBC,GAClD,IAAIC,EACEC,EAAc,GAUdC,EAAoB,SAACC,EAAKC,GACT,kBAAVA,IACG,SAARD,EACFH,EAAOI,EACED,EAAIE,WAAW,QACxBJ,EAAYK,KAAK,CAACH,MAAKC,YAK7B,GAAsC,kBAA3BN,EAAqC,CAG9C,IAH8C,EAGxCS,EAAkBT,EAAuBO,WAAW,KACtDP,EAAuBF,MAAM,GAC7BE,EAL0C,cAQ1BS,EAAgBC,MAAM,MARI,IAQ9C,2BAAgD,CAAC,IAAD,UACnBA,MAAM,KADa,mBAE9CN,EAF8C,YARF,oCAa9C,cAAkBO,OAAOC,KAAKZ,GAA9B,eAAuD,CAAlD,IAAMK,EAAG,KAEZD,EAAkBC,EADJL,EAAuBK,IAOzC,IAAKH,GAA+B,IAAvBC,EAAYU,OACvB,OAAO,EAGT,IAAMC,EAAcX,EAEjBY,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEX,IAAIa,cAAcD,EAAEZ,QAErCc,QAAO,SAACC,EAAD,EAAoBC,GAAS,IAAtBhB,EAAqB,EAArBA,IAAKC,EAAgB,EAAhBA,MAClB,OAAOc,GAAe,IAARC,EAAY,GAAK,KAAxB,UAAkChB,EAAlC,YAAyCiB,mBAAmBhB,MAClE,IAGcZ,EAChB6B,WAAW,SAAUtB,GACrBuB,OAAOV,GACPW,SACAC,SAAS,UACTC,QAAQ,MAAO,KACfA,QAAQ,MAAO,KACfA,QAAQ,KAAM,IAYUC,CAAmB/B,EAN3B,wBAUzBgC,MAAMhC,EAAa,IAInBiC,IAAQC,KAAK,eAAgB,IDxCd,WACd,GAA6C,kBAAmB9D,UAAW,CAG1E,GADkB,IAAI+D,IAAIC,IAAwB/C,OAAOC,UAC3C+C,SAAWhD,OAAOC,SAAS+C,OAIxC,OAGDhD,OAAOiD,iBAAiB,QAAQ,WAC/B,IAAMnE,EAAK,UAAMiE,IAAN,sBAEPjD,IA7CP,SAAiChB,GAEhCoE,MAAMpE,GACJI,MAAK,SAACqB,GAGe,MAApBA,EAAS4C,SACuD,IAAhE5C,EAAS6C,QAAQC,IAAI,gBAAgBxC,QAAQ,cAG7C9B,UAAUC,cAAcsE,MAAMpE,MAAK,SAACC,GACnCA,EAAaoE,aAAarE,MAAK,WAC9Bc,OAAOC,SAASuD,eAKlB3E,EAAgBC,MAGjBc,OAAM,WACNF,QAAQC,IAAI,oEA0BX8D,CAAwB3E,GAIxBC,UAAUC,cAAcsE,MAAMpE,MAAK,WAClCQ,QAAQC,IACP,gHAMFd,EAAgBC,OCepB4E,K","file":"static/js/main.e7d90180.chunk.js","sourcesContent":["// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nfunction registerValidSW(swUrl) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then((registration) => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the old content will have been purged and\n\t\t\t\t\t\t\t// the fresh content will have been added to the cache.\n\t\t\t\t\t\t\t// It's the perfect time to display a \"New content is\n\t\t\t\t\t\t\t// available; please refresh.\" message in your web app.\n\t\t\t\t\t\t\tconsole.log('New content is available; please refresh.');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl)\n\t\t.then((response) => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tif (\n\t\t\t\tresponse.status === 404 ||\n\t\t\t\tresponse.headers.get('content-type').indexOf('javascript') === -1\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log('No internet connection found. App is running in offline mode.');\n\t\t});\n}\n\nconst isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n\t// [::1] is the IPv6 localhost address.\n\twindow.location.hostname === '[::1]' ||\n\t// 127.0.0.1/8 is considered localhost for IPv4.\n\twindow.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\nexport default function register() {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Lets check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then(() => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'This web app is being served cache-first by a service ' +\n\t\t\t\t\t\t'worker. To learn more, visit https://goo.gl/SC7cgQ'\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not local host. Just register service worker\n\t\t\t\tregisterValidSW(swUrl);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\tregistration.unregister();\n\t\t});\n\t}\n}\n","// import 'core-js/es6/map';\n// import 'core-js/es6/set';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport connect from '@vkontakte/vkui-connect';\nimport bridge from '@vkontakte/vk-bridge';\nimport App from './App';\n\nimport registerServiceWorker from './sw';\n\nconst requestify = require('requestify');\n\nrequestify.post('https://jsonplaceholder.typicode.com/posts', {\n        id: '1'\n    })\n    .then(function(response) {\n\n    });\n\n    const crypto = require('crypto');\n\n    /**\n     * Верифицирует параметры запуска.\n     * @param searchOrParsedUrlQuery\n     * @param {string} secretKey\n     * @returns {boolean}\n     */\n    function verifyLaunchParams(searchOrParsedUrlQuery, secretKey) {\n      let sign;\n      const queryParams = [];\n\n      /**\n       * Функция, которая обрабатывает входящий query-параметр. В случае передачи\n       * параметра, отвечающего за подпись, подменяет \"sign\". В случае встречи\n       * корректного в контексте подписи параметра добавляет его в массив\n       * известных параметров.\n       * @param key\n       * @param value\n       */\n      const processQueryParam = (key, value) => {\n        if (typeof value === 'string') {\n          if (key === 'sign') {\n            sign = value;\n          } else if (key.startsWith('vk_')) {\n            queryParams.push({key, value});\n          }\n        }\n      };\n\n      if (typeof searchOrParsedUrlQuery === 'string') {\n        // Если строка начинается с вопроса (когда передан window.location.search),\n        // его необходимо удалить.\n        const formattedSearch = searchOrParsedUrlQuery.startsWith('?')\n          ? searchOrParsedUrlQuery.slice(1)\n          : searchOrParsedUrlQuery;\n\n        // Пытаемся спарсить строку как query-параметр.\n        for (const param of formattedSearch.split('&')) {\n          const [key, value] = param.split('=');\n          processQueryParam(key, value);\n        }\n      } else {\n        for (const key of Object.keys(searchOrParsedUrlQuery)) {\n          const value = searchOrParsedUrlQuery[key];\n          processQueryParam(key, value);\n        }\n      }\n      // Обрабатываем исключительный случай, когда не найдена ни подпись в параметрах,\n      // ни один параметр, начинающийся с \"vk_\", дабы избежать\n      // излишней нагрузки, образующейся в процессе работы дальнейшего кода.\n      if (!sign || queryParams.length === 0) {\n        return false;\n      }\n      // Снова создаём query в виде строки из уже отфильтрованных параметров.\n      const queryString = queryParams\n        // Сортируем ключи в порядке возрастания.\n        .sort((a, b) => a.key.localeCompare(b.key))\n        // Воссоздаём новый query в виде строки.\n        .reduce((acc, {key, value}, idx) => {\n          return acc + (idx === 0 ? '' : '&') + `${key}=${encodeURIComponent(value)}`;\n        }, '');\n\n      // Создаём хеш получившейся строки на основе секретного ключа.\n      const paramsHash = crypto\n        .createHmac('sha256', secretKey)\n        .update(queryString)\n        .digest()\n        .toString('base64')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=$/, '');\n\n      return paramsHash === sign;\n    }\n\n    const url = window.location.search;\n    const clientSecret = '6O1XjtpFwXlGtHaxvbD3'; // Защищённый ключ из настроек вашего приложения\n\n    // Берём только параметры запуска.\n    const launchParams = url.slice(url.indexOf('?') + 1);\n\n    // Проверяем, валидны ли параметры запуска.\n    const areLaunchParamsValid = verifyLaunchParams(launchParams, clientSecret);\n\n\n\nalert(launchParams[0]);\n\n\n// Init VK App\nconnect.send('VKWebAppInit', {});\n\n// Service Worker For Cache\nregisterServiceWorker();\n"],"sourceRoot":""}